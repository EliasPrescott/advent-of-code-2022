(defun parse-stack-line (line)
  (mapcar (lambda (index)
            (if (char-equal (char line index) #\[)
                (char line (+ index 1))
                '()))
          '(0 4 8 12 16 20 24 28 32)))

(defun parse-move-line (line)
  (let ((parsed-words (mapcar (lambda (y) (parse-integer y :junk-allowed t)) (uiop:split-string line :separator " "))))
    (loop for x in parsed-words and index from 0
                when x
                collect x)))

(defun parse-input (path)
  (remove-if (lambda (x) (equal (first x) 'ignore))
             (mapcar (lambda (line)
                          (if (= (length line) 0)
                              (list 'ignore)
                              (cond ((char-equal (char line 0) #\[) (list 'stack (parse-stack-line line)))
                                    ((char-equal (char line 0) #\space)
                                     (if (char-equal (char line 1) #\1)
                                         (list 'ignore)
                                         (list 'stack (parse-stack-line line))))
                                    (t (list 'move (parse-move-line line))))))
                        (uiop:read-file-lines path))))

(defun rows-to-columns (row-list)
  (loop for row-index from 0 below (length (first row-list))
        collect (loop for col-index from 0 below (length row-list)
                      collect (nth row-index (nth col-index row-list)))))

(defun part-1-solver (input-path)
  (let ((input-data (parse-input input-path)))
    (let ((stacks (mapcar (lambda (x) (remove nil x))
                          (rows-to-columns (mapcar #'second (remove-if-not (lambda (x)
                                                                             (equal (first x) 'stack)) input-data)))))
          (moves (mapcar #'second (remove-if-not (lambda (x) (equal (first x) 'move)) input-data))))
      (dolist (move moves)
        (let ((moving-blocks (subseq (nth (- (second move) 1) stacks) 0 (first move))))
          (setf (nth (- (second move) 1) stacks)
                (subseq (nth (- (second move) 1) stacks) (first move)))
          (setf (nth (- (third move) 1) stacks)
                (append (reverse moving-blocks) (nth (- (third move) 1) stacks)))))
      (concatenate 'string (mapcar #'first stacks)))))

(defun part-2-solver (input-path)
  (let ((input-data (parse-input input-path)))
    (let ((stacks (mapcar (lambda (x) (remove nil x))
                          (rows-to-columns (mapcar #'second (remove-if-not (lambda (x)
                                                                             (equal (first x) 'stack)) input-data)))))
          (moves (mapcar #'second (remove-if-not (lambda (x) (equal (first x) 'move)) input-data))))
      (dolist (move moves)
        (let ((moving-blocks (subseq (nth (- (second move) 1) stacks) 0 (first move))))
          (setf (nth (- (second move) 1) stacks)
                (subseq (nth (- (second move) 1) stacks) (first move)))
          (setf (nth (- (third move) 1) stacks)
                (append moving-blocks (nth (- (third move) 1) stacks)))))
      (concatenate 'string (mapcar #'first stacks)))))
